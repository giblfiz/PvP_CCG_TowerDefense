<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Defense Map Demo</title>
    <link rel="stylesheet" href="css/phaser-game.css">
</head>
<body>
    <div id="info-panel">Tower Defense Map Demo</div>
    <div id="help-panel">
        üìå Drag to pan<br>
        üîç Pinch/scroll to zoom<br>
        üèóÔ∏è Click to place towers<br>
        <button id="cleanup-button" style="margin-top: 10px; padding: 5px; cursor: pointer;">Force Cleanup</button>
    </div>
    <div id="game-container"></div>
    
    <div id="hud-panel">
        <div class="stat">
            <span class="stat-label">Gold:</span>
            <span class="stat-value" id="gold-value">600</span>
        </div>
        <div class="stat">
            <span class="stat-label">Lives:</span>
            <span class="stat-value" id="lives-value">20</span>
        </div>
        <div class="stat">
            <span class="stat-label">Wave:</span>
            <span class="stat-value" id="wave-value">0</span>
        </div>
        <div class="stat">
            <button id="wave-button" style="width: 100%; padding: 5px; margin-top: 5px; cursor: pointer;">Start Wave</button>
        </div>
    </div>
    
    <div id="tower-selection">
        <div class="tower-button" data-type="basic" data-cost="50">
            üóº
            <div class="tower-cost">50</div>
        </div>
        <div class="tower-button" data-type="sniper" data-cost="100">
            üèØ
            <div class="tower-cost">100</div>
        </div>
        <div class="tower-button" data-type="splash" data-cost="150">
            üè∞
            <div class="tower-cost">150</div>
        </div>
    </div>
    
    <div id="error-display"></div>

    <!-- Server Logger (optional) -->
    <script src="src/ui/ServerLogger.js"></script>
    
    <!-- Load game components -->
    <script src="src/core/PhaserMook.js"></script>
    <script src="src/phaser/PhaserRenderer.js"></script>
    <script src="src/phaser/PhaserGame.js" defer></script>
    
    <!-- Error handling script -->
    <script>
        
        // Initialize server logger if available (but disabled by default)
        let logger;
        try {
            logger = new ServerLogger({
                endpoint: '/api/log',
                enabled: false, // Disabled by default
                logToConsole: true,
                batchInterval: 3000, // Longer interval to reduce performance impact
                contextInfo: {
                    gameVersion: '1.0.0',
                    url: window.location.href
                }
            });
            console.log('Server logger is available. Set window.enableServerLogging = true to enable.');
            
            // Add global functions to enable/disable server logging
            window.enableServerLogging = function() {
                logger.setEnabled(true);
                console.log('Server logging enabled');
                return 'Server logging enabled';
            };
            
            window.disableServerLogging = function() {
                logger.setEnabled(false);
                console.log('Server logging disabled');
                return 'Server logging disabled';
            };
        } catch (e) {
            console.log('Server logger not available:', e.message);
        }
        
        // Custom error handler to display errors in the page
        const errorDisplay = document.getElementById('error-display');
        
        // Store original console methods
        const originalConsoleError = console.error;
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        
        // Override console.error
        console.error = function() {
            // Call original method
            originalConsoleError.apply(console, arguments);
            
            // Display in our error div
            const errorMessage = Array.from(arguments).join(' ');
            displayError('ERROR: ' + errorMessage);
            
            // Send to server logger if enabled
            if (logger && logger.options.enabled) {
                logger.error(errorMessage);
            }
        };
        
        // Override console.warn
        console.warn = function() {
            // Call original method
            originalConsoleWarn.apply(console, arguments);
            
            // Display in our error div
            const warnMessage = Array.from(arguments).join(' ');
            displayError('WARNING: ' + warnMessage);
            
            // Send to server logger if enabled
            if (logger && logger.options.enabled) {
                logger.warn(warnMessage);
            }
        };
        
        // Also intercept console.log for cleanup/mook related messages
        console.log = function() {
            // Call original method
            originalConsoleLog.apply(console, arguments);
            
            // Send important logs to server logger if enabled - with much stricter filtering to prevent overload
            if (logger && logger.options.enabled) {
                const logMessage = Array.from(arguments).join(' ');
                // Only log critical cleanup messages to avoid flooding
                if ((logMessage.includes('cleanup') && logMessage.includes('complete')) || 
                    (logMessage.includes('Force cleanup') && !logMessage.includes('clicked')) || 
                    (logMessage.includes('Destroyed') && logMessage.includes('sprite')) ||
                    (logMessage.includes('PERIODIC CLEANUP') || logMessage.includes('BEFORE CLEANUP') || logMessage.includes('AFTER CLEANUP'))) {
                    logger.info(logMessage);
                }
            }
        };
        
        // Handle window errors
        window.addEventListener('error', function(e) {
            const errorMsg = 'EXCEPTION: ' + e.message + ' at ' + e.filename + ':' + e.lineno;
            displayError(errorMsg);
            
            // Send to server logger if enabled
            if (logger && logger.options.enabled) {
                logger.error(errorMsg, { stack: e.error ? e.error.stack : null });
            }
            return false;
        });
        
        // Handle promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            const errorMsg = 'UNHANDLED PROMISE REJECTION: ' + e.reason;
            displayError(errorMsg);
            
            // Send to server logger if enabled
            if (logger && logger.options.enabled) {
                logger.error(errorMsg, { reason: e.reason });
            }
        });
        
        function displayError(message) {
            errorDisplay.style.display = 'block';
            const errorLine = document.createElement('div');
            errorLine.textContent = message;
            errorDisplay.appendChild(errorLine);
            
            // Scroll to bottom
            errorDisplay.scrollTop = errorDisplay.scrollHeight;
        }
    </script>

    <!-- Load Phaser library (using full version for better debugging) -->
    <script src="vendors/phaser/phaser.js" onerror="displayError('Failed to load Phaser library. Check if the file exists at vendors/phaser/phaser.js')"></script>
    
    <!-- Game code -->
    <script>
        // Check if Phaser exists before continuing
        if (typeof Phaser === 'undefined') {
            displayError('Phaser is not defined! The Phaser library failed to load correctly.');
        } else {
            console.log('Phaser loaded successfully:', Phaser.VERSION);
        }
    
        // We're now using the PhaserMook class from an external file
        // Define an alias to maintain compatibility with existing code
        const Mook = PhaserMook;
        
        /**
         * Tower class definition
         */
        class Tower {
            static TOWER_BASIC = 'basic';
            static TOWER_SNIPER = 'sniper';
            static TOWER_SPLASH = 'splash';
            
            constructor(type, gridX, gridY) {
                this.type = type;
                this.gridX = gridX;
                this.gridY = gridY;
                this.level = 1;
                this.target = null;
                
                // Set stats based on tower type
                switch(type) {
                    case Tower.TOWER_BASIC:
                        this.damage = 20;
                        this.range = 3;
                        this.fireRate = 1;
                        this.cost = 50;
                        this.upgradeCost = 40;
                        this.emoji = 'üóº';
                        this.splashRadius = 0;
                        break;
                    case Tower.TOWER_SNIPER:
                        this.damage = 50;
                        this.range = 6;
                        this.fireRate = 0.5;
                        this.cost = 100;
                        this.upgradeCost = 80;
                        this.emoji = 'üèØ';
                        this.splashRadius = 0;
                        break;
                    case Tower.TOWER_SPLASH:
                        this.damage = 15;
                        this.range = 2;
                        this.fireRate = 0.8;
                        this.cost = 150;
                        this.upgradeCost = 120;
                        this.emoji = 'üè∞';
                        this.splashRadius = 1; // Splash radius in grid cells
                        break;
                    default:
                        this.damage = 10;
                        this.range = 2;
                        this.fireRate = 1;
                        this.cost = 50;
                        this.upgradeCost = 40;
                        this.emoji = 'üóº';
                        this.splashRadius = 0;
                }
                
                this.lastFired = 0;
            }
            
            upgrade() {
                this.level++;
                this.damage *= 1.5;
                this.range += 0.5;
                this.fireRate *= 1.2;
                this.upgradeCost = Math.floor(this.upgradeCost * 1.5);
            }
            
            canFire(time) {
                return time - this.lastFired >= 1000 / this.fireRate;
            }
            
            fire(time) {
                this.lastFired = time;
                return this.damage;
            }
            
            isInRange(mook, cellSize) {
                const towerX = this.gridX * cellSize + cellSize/2;
                const towerY = this.gridY * cellSize + cellSize/2;
                const mookX = mook.position.x * cellSize + cellSize/2;
                const mookY = mook.position.y * cellSize + cellSize/2;
                
                const distance = Phaser.Math.Distance.Between(towerX, towerY, mookX, mookY);
                return distance <= this.range * cellSize;
            }
            
            findTarget(mooks, cellSize) {
                // Find all mooks in range
                const inRangeMooks = mooks.filter(mook => 
                    mook.active && !mook.reachedEnd && this.isInRange(mook, cellSize)
                );
                
                if (inRangeMooks.length === 0) {
                    this.target = null;
                    return null;
                }
                
                // Different target selection based on tower type
                switch(this.type) {
                    case Tower.TOWER_SNIPER:
                        // Sniper targets the one with the most health
                        this.target = inRangeMooks.reduce((prev, current) => 
                            (prev.health > current.health) ? prev : current
                        );
                        break;
                        
                    case Tower.TOWER_SPLASH:
                        // Splash tower targets the one with most neighbors 
                        // for maximum splash damage
                        let maxNeighbors = 0;
                        let bestTarget = inRangeMooks[0];
                        
                        for (const mook of inRangeMooks) {
                            const neighbors = inRangeMooks.filter(other => {
                                if (other === mook) return false;
                                
                                const dx = Math.abs(other.position.x - mook.position.x);
                                const dy = Math.abs(other.position.y - mook.position.y);
                                return dx <= this.splashRadius && dy <= this.splashRadius;
                            }).length;
                            
                            if (neighbors > maxNeighbors) {
                                maxNeighbors = neighbors;
                                bestTarget = mook;
                            }
                        }
                        
                        this.target = bestTarget;
                        break;
                        
                    default: // Basic tower and others
                        // Target the furthest along the path
                        this.target = inRangeMooks.reduce((prev, current) => 
                            (current.currentPathIndex > prev.currentPathIndex || 
                             (current.currentPathIndex === prev.currentPathIndex && 
                              current.progress > prev.progress)) ? current : prev
                        );
                }
                
                return this.target;
            }
            
            attackTarget(time, mooks, cellSize) {
                if (!this.canFire(time)) return null;
                
                const target = this.findTarget(mooks, cellSize);
                if (!target) return null;
                
                // Fire the tower
                const damage = this.fire(time);
                
                // Handle splash damage
                if (this.splashRadius > 0) {
                    // Get all mooks in splash radius
                    const splashedMooks = mooks.filter(mook => {
                        if (!mook.active || mook.reachedEnd) return false;
                        if (mook === target) return true; // Direct target always gets hit
                        
                        const dx = Math.abs(mook.position.x - target.position.x);
                        const dy = Math.abs(mook.position.y - target.position.y);
                        return dx <= this.splashRadius && dy <= this.splashRadius;
                    });
                    
                    // Apply damage to all mooks in splash radius
                    const results = [];
                    for (const mook of splashedMooks) {
                        const distanceRatio = mook === target ? 1 : 0.5; // Reduced damage for splash
                        const isDead = mook.takeDamage(damage * distanceRatio);
                        if (isDead) {
                            results.push({
                                mook,
                                isDead: true
                            });
                        } else {
                            results.push({
                                mook,
                                isDead: false
                            });
                        }
                    }
                    return results;
                } else {
                    // Direct damage to single target
                    const isDead = target.takeDamage(damage);
                    return [{
                        mook: target,
                        isDead
                    }];
                }
            }
        }
    
        /**
         * Map definition
         */
        class TDMap {
            static CELL_EMPTY = 0;
            static CELL_PATH = 1;
            static CELL_SPAWN = 2;
            static CELL_EXIT = 3;
            static CELL_TOWER = 4;
            
            constructor(width = 20, height = 15) {
                this.width = width;
                this.height = height;
                this.numPaths = 3; // Number of paths to generate
                
                // Initialize grid
                this.grid = [];
                for (let x = 0; x < this.width; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < this.height; y++) {
                        this.grid[x][y] = TDMap.CELL_EMPTY;
                    }
                }
                
                // Initialize paths, spawn points, and exit points
                this.paths = [];
                this.spawnPoints = [];
                this.exitPoints = [];
                
                // Generate a default map
                this.generateMap();
            }
            
            generateMap() {
                // Clear existing data
                this.paths = [];
                this.spawnPoints = [];
                this.exitPoints = [];
                
                // Reset grid to empty
                for (let x = 0; x < this.width; x++) {
                    for (let y = 0; y < this.height; y++) {
                        this.grid[x][y] = TDMap.CELL_EMPTY;
                    }
                }
                
                // Generate multiple paths
                for (let i = 0; i < this.numPaths; i++) {
                    this.generateSinglePath(i);
                }
            }
            
            generateSinglePath(pathIndex) {
                // Calculate spawn and exit positions based on path index
                let spawnPoint, exitPoint;
                
                if (pathIndex === 0) {
                    // Top path: spawn at left, exit at right
                    const spawnY = Math.floor(this.height * 0.25);
                    spawnPoint = { x: 0, y: spawnY };
                    
                    const exitY = Math.floor(this.height * 0.25);
                    exitPoint = { x: this.width - 1, y: exitY };
                } 
                else if (pathIndex === 1) {
                    // Middle path: spawn at left, exit at right
                    const spawnY = Math.floor(this.height * 0.5);
                    spawnPoint = { x: 0, y: spawnY };
                    
                    const exitY = Math.floor(this.height * 0.5);
                    exitPoint = { x: this.width - 1, y: exitY };
                }
                else {
                    // Bottom path: spawn at left, exit at right
                    const spawnY = Math.floor(this.height * 0.75);
                    spawnPoint = { x: 0, y: spawnY };
                    
                    const exitY = Math.floor(this.height * 0.75);
                    exitPoint = { x: this.width - 1, y: exitY };
                }
                
                // Add spawn and exit points
                this.addSpawnPoint(spawnPoint.x, spawnPoint.y);
                this.addExitPoint(exitPoint.x, exitPoint.y);
                
                // Generate path from spawn to exit with some complexity
                const path = this.findComplexPath(spawnPoint, exitPoint, pathIndex);
                this.addPath(path);
                
                return path;
            }
            
            findComplexPath(start, end, pathIndex) {
                // Create a more interesting path than just a straight line
                const path = [];
                path.push({ ...start });
                
                // Divide the width into segments for path complexity
                const segments = 4;
                const segmentWidth = this.width / segments;
                
                // Calculate waypoints based on path index
                const waypoints = [];
                
                if (pathIndex === 0) {
                    // Top path: moves right, then down, then right, then up, then right
                    waypoints.push({ x: Math.floor(segmentWidth), y: start.y });
                    waypoints.push({ x: Math.floor(segmentWidth), y: Math.floor(this.height * 0.5) });
                    waypoints.push({ x: Math.floor(segmentWidth * 2), y: Math.floor(this.height * 0.5) });
                    waypoints.push({ x: Math.floor(segmentWidth * 2), y: Math.floor(this.height * 0.25) });
                    waypoints.push({ x: Math.floor(segmentWidth * 3), y: Math.floor(this.height * 0.25) });
                } 
                else if (pathIndex === 1) {
                    // Middle path: moves right, then up, then right, then down, then right
                    waypoints.push({ x: Math.floor(segmentWidth), y: start.y });
                    waypoints.push({ x: Math.floor(segmentWidth), y: Math.floor(this.height * 0.25) });
                    waypoints.push({ x: Math.floor(segmentWidth * 2), y: Math.floor(this.height * 0.25) });
                    waypoints.push({ x: Math.floor(segmentWidth * 2), y: Math.floor(this.height * 0.75) });
                    waypoints.push({ x: Math.floor(segmentWidth * 3), y: Math.floor(this.height * 0.75) });
                    waypoints.push({ x: Math.floor(segmentWidth * 3), y: Math.floor(this.height * 0.5) });
                }
                else {
                    // Bottom path: moves right, then up, then right, then up, then right
                    waypoints.push({ x: Math.floor(segmentWidth), y: start.y });
                    waypoints.push({ x: Math.floor(segmentWidth), y: Math.floor(this.height * 0.5) });
                    waypoints.push({ x: Math.floor(segmentWidth * 2), y: Math.floor(this.height * 0.5) });
                    waypoints.push({ x: Math.floor(segmentWidth * 3), y: Math.floor(this.height * 0.5) });
                    waypoints.push({ x: Math.floor(segmentWidth * 3), y: Math.floor(this.height * 0.75) });
                }
                
                // Add the end point
                waypoints.push(end);
                
                // Connect all waypoints with straight lines
                let current = { ...start };
                
                for (const waypoint of waypoints) {
                    // Go to waypoint X first, then Y (no diagonals)
                    while (current.x !== waypoint.x || current.y !== waypoint.y) {
                        // Move horizontally first
                        if (current.x < waypoint.x) {
                            current.x += 1;
                        } else if (current.x > waypoint.x) {
                            current.x -= 1;
                        }
                        // Then move vertically
                        else if (current.y < waypoint.y) {
                            current.y += 1;
                        } else if (current.y > waypoint.y) {
                            current.y -= 1;
                        }
                        
                        path.push({ ...current });
                    }
                }
                
                return path;
            }
            
            findPath(start, end) {
                const path = [];
                let current = { ...start };
                path.push({ ...current });
                
                // Simple path algorithm - go horizontal first, then vertical
                while (current.x !== end.x || current.y !== end.y) {
                    // Move horizontally first
                    if (current.x < end.x) {
                        current.x += 1;
                    } else if (current.x > end.x) {
                        current.x -= 1;
                    }
                    // Then move vertically
                    else if (current.y < end.y) {
                        current.y += 1;
                    } else if (current.y > end.y) {
                        current.y -= 1;
                    }
                    
                    path.push({ ...current });
                }
                
                return path;
            }
            
            addSpawnPoint(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                this.spawnPoints.push({ x, y });
                this.grid[x][y] = TDMap.CELL_SPAWN;
                return true;
            }
            
            addExitPoint(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                this.exitPoints.push({ x, y });
                this.grid[x][y] = TDMap.CELL_EXIT;
                return true;
            }
            
            addPath(path) {
                // Verify path
                if (!Array.isArray(path) || path.length < 2) {
                    return false;
                }
                
                // Add path to map
                this.paths.push([...path]);
                
                // Mark all path cells in grid
                for (let i = 0; i < path.length; i++) {
                    const { x, y } = path[i];
                    if (this.isValidPosition(x, y)) {
                        // Skip overwriting spawn and exit points
                        if (this.grid[x][y] !== TDMap.CELL_SPAWN && this.grid[x][y] !== TDMap.CELL_EXIT) {
                            this.grid[x][y] = TDMap.CELL_PATH;
                        }
                    }
                }
                
                return true;
            }
            
            isValidPosition(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }
            
            getCellValue(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return -1;
                }
                
                return this.grid[x][y];
            }
            
            canPlaceTower(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                // Can only place towers on empty cells
                return this.grid[x][y] === TDMap.CELL_EMPTY;
            }
            
            placeTower(x, y) {
                if (!this.canPlaceTower(x, y)) {
                    return false;
                }
                
                this.grid[x][y] = TDMap.CELL_TOWER;
                return true;
            }
            
            removeTower(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                if (this.grid[x][y] === TDMap.CELL_TOWER) {
                    this.grid[x][y] = TDMap.CELL_EMPTY;
                    return true;
                }
                
                return false;
            }
        }
        
        /**
         * Game state
         */
        class GameState {
            constructor() {
                this.gold = 600;
                this.lives = 20;
                this.wave = 0;
                this.towers = [];
                this.mooks = [];
                this.waveActive = false;
                this.waveTimer = null;
                this.gameOver = false;
                this.mooksSpawned = 0;
                this.mooksKilled = 0;
                this.mooksLeaked = 0;
                
                // Wave configuration
                this.waveConfig = {
                    spawnDelay: 1000, // ms between spawns
                    mooksPerWave: 10, // base number of mooks per wave
                    mookTypes: [
                        { type: Mook.MOOK_STANDARD, weight: 100 },
                        { type: Mook.MOOK_FAST, weight: 0 },
                        { type: Mook.MOOK_ARMORED, weight: 0 },
                        { type: Mook.MOOK_TANK, weight: 0 }
                    ],
                    // Define when special mooks appear
                    specialMooks: {
                        [Mook.MOOK_FAST]: 2, // Fast mooks appear at wave 2
                        [Mook.MOOK_ARMORED]: 3, // Armored mooks appear at wave 3
                        [Mook.MOOK_TANK]: 5 // Tank mooks appear at wave 5
                    },
                    maxWaves: 10
                };
                
                // Update UI
                this.updateUI();
            }
            
            addGold(amount) {
                this.gold += amount;
                this.updateUI();
            }
            
            spendGold(amount) {
                if (this.gold >= amount) {
                    this.gold -= amount;
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            reduceLives(amount) {
                this.lives -= amount;
                this.updateUI();
                
                if (this.lives <= 0) {
                    this.gameOver = true;
                    this.endWave();
                    
                    // Show game over message
                    const infoPanel = document.getElementById('info-panel');
                    infoPanel.textContent = 'GAME OVER! You reached wave ' + this.wave;
                    infoPanel.style.color = '#ff5555';
                    infoPanel.style.fontWeight = 'bold';
                    
                    // Disable wave button
                    document.getElementById('wave-button').textContent = 'Game Over';
                    document.getElementById('wave-button').disabled = true;
                }
            }
            
            startWave() {
                if (this.gameOver) return false;
                if (!this.waveActive) {
                    this.wave++;
                    this.waveActive = true;
                    this.mooksSpawned = 0;
                    this.mooksKilled = 0;
                    this.mooksLeaked = 0;
                    this.mooks = [];
                    
                    // Add bonus gold for starting a wave
                    this.addGold(25);
                    
                    // Update wave configuration based on wave number
                    this.updateWaveConfig();
                    
                    // Update UI
                    this.updateUI();
                    
                    return true;
                }
                return false;
            }
            
            updateWaveConfig() {
                // Update mook type weights based on wave number
                this.waveConfig.mookTypes.forEach(mookType => {
                    if (mookType.type === Mook.MOOK_STANDARD) {
                        // Standard mooks always present but decrease in later waves
                        mookType.weight = Math.max(10, 100 - this.wave * 10);
                    } else if (mookType.type === Mook.MOOK_FAST && this.wave >= this.waveConfig.specialMooks[Mook.MOOK_FAST]) {
                        // Fast mooks appear at wave 2 and increase
                        mookType.weight = (this.wave - this.waveConfig.specialMooks[Mook.MOOK_FAST] + 1) * 20;
                    } else if (mookType.type === Mook.MOOK_ARMORED && this.wave >= this.waveConfig.specialMooks[Mook.MOOK_ARMORED]) {
                        // Armored mooks appear at wave 3 and increase
                        mookType.weight = (this.wave - this.waveConfig.specialMooks[Mook.MOOK_ARMORED] + 1) * 15;
                    } else if (mookType.type === Mook.MOOK_TANK && this.wave >= this.waveConfig.specialMooks[Mook.MOOK_TANK]) {
                        // Tank mooks appear at wave 5 and increase slowly
                        mookType.weight = (this.wave - this.waveConfig.specialMooks[Mook.MOOK_TANK] + 1) * 10;
                    }
                });
                
                // Increase mooks per wave
                this.waveConfig.mooksPerWave = 10 + (this.wave * 2);
                
                // Decrease spawn delay slightly
                this.waveConfig.spawnDelay = Math.max(500, 1000 - (this.wave * 50));
            }
            
            spawnMook(path) {
                if (!this.waveActive || this.mooksSpawned >= this.waveConfig.mooksPerWave) {
                    return null;
                }
                
                // Select mook type based on weights
                const mookType = this.selectMookType();
                
                // Create new mook
                const mook = new Mook(mookType, path);
                this.mooks.push(mook);
                this.mooksSpawned++;
                
                // Check if this was the last mook to spawn
                if (this.mooksSpawned >= this.waveConfig.mooksPerWave) {
                    // Clear spawn timer if it's the last mook
                    if (this.waveTimer) {
                        clearTimeout(this.waveTimer);
                        this.waveTimer = null;
                    }
                }
                
                return mook;
            }
            
            selectMookType() {
                // Get total weight
                const totalWeight = this.waveConfig.mookTypes.reduce((sum, type) => sum + type.weight, 0);
                
                // Random value based on total weight
                let random = Math.random() * totalWeight;
                
                // Select mook type
                for (const mookType of this.waveConfig.mookTypes) {
                    if (random < mookType.weight) {
                        return mookType.type;
                    }
                    random -= mookType.weight;
                }
                
                // Default to standard mook
                return Mook.MOOK_STANDARD;
            }
            
            mookReachedEnd(mook) {
                // Mark mook as inactive and reached end
                mook.active = false;
                mook.reachedEnd = true;
                
                // Reduce lives
                this.reduceLives(mook.damage);
                
                // Track leaked mooks
                this.mooksLeaked++;
                
                // Check if wave is complete
                this.checkWaveCompletion();
            }
            
            mookKilled(mook) {
                // Mark mook as inactive
                mook.active = false;
                
                // Add gold reward
                this.addGold(mook.reward);
                
                // Track killed mooks
                this.mooksKilled++;
                
                // Check if wave is complete
                this.checkWaveCompletion();
            }
            
            checkWaveCompletion() {
                // Wave is complete when all mooks are spawned and either killed or reached the end
                if (this.waveActive && 
                    this.mooksSpawned >= this.waveConfig.mooksPerWave && 
                    this.mooksKilled + this.mooksLeaked >= this.mooksSpawned &&
                    !this.gameOver) {
                    
                    this.endWave();
                }
            }
            
            endWave() {
                if (!this.waveActive) return;
                
                this.waveActive = false;
                
                // Clear any remaining spawn timer
                if (this.waveTimer) {
                    clearTimeout(this.waveTimer);
                    this.waveTimer = null;
                }
                
                // Add wave completion bonus if not game over
                if (!this.gameOver) {
                    this.addGold(50 + (this.wave * 10));
                    
                    // Check for game win
                    if (this.wave >= this.waveConfig.maxWaves) {
                        const infoPanel = document.getElementById('info-panel');
                        infoPanel.textContent = 'YOU WIN! You completed all waves!';
                        infoPanel.style.color = '#55ff55';
                        infoPanel.style.fontWeight = 'bold';
                        
                        // Update button
                        document.getElementById('wave-button').textContent = 'Victory!';
                        document.getElementById('wave-button').disabled = true;
                        
                        this.gameOver = true;
                    }
                }
                
                // Update UI
                this.updateUI();
            }
            
            updateUI() {
                document.getElementById('gold-value').textContent = this.gold;
                document.getElementById('lives-value').textContent = this.lives;
                document.getElementById('wave-value').textContent = this.wave;
                
                // Update wave button
                if (this.gameOver) {
                    document.getElementById('wave-button').textContent = this.lives <= 0 ? 'Game Over' : 'Victory!';
                    document.getElementById('wave-button').disabled = true;
                } else if (this.waveActive) {
                    const progress = Math.floor((this.mooksKilled + this.mooksLeaked) / this.waveConfig.mooksPerWave * 100);
                    document.getElementById('wave-button').textContent = `Wave in Progress - ${progress}%`;
                    document.getElementById('wave-button').disabled = true;
                } else {
                    document.getElementById('wave-button').textContent = this.wave === 0 ? 'Start Game' : 'Start Wave ' + (this.wave + 1);
                    document.getElementById('wave-button').disabled = false;
                }
            }
            
            addTower(tower) {
                this.towers.push(tower);
            }
            
            removeTower(gridX, gridY) {
                const index = this.towers.findIndex(t => t.gridX === gridX && t.gridY === gridY);
                if (index !== -1) {
                    const tower = this.towers[index];
                    this.towers.splice(index, 1);
                    
                    // Refund some of the cost
                    this.addGold(Math.floor(tower.cost * 0.7));
                    return true;
                }
                return false;
            }
            
            getTower(gridX, gridY) {
                return this.towers.find(t => t.gridX === gridX && t.gridY === gridY);
            }
            
            update(time, deltaTime) {
                // Skip updates if game over
                if (this.gameOver) return;
                
                // Update mooks
                this.updateMooks(deltaTime);
                
                // Update towers
                this.updateTowers(time);
            }
            
            updateMooks(deltaTime) {
                // Scale deltaTime to seconds
                const deltaSeconds = deltaTime / 1000;
                
                for (let i = 0; i < this.mooks.length; i++) {
                    const mook = this.mooks[i];
                    
                    // Skip inactive mooks
                    if (!mook.active) continue;
                    
                    // Update mook position
                    const reachedEnd = mook.update(deltaSeconds);
                    
                    // Check if mook reached the end
                    if (reachedEnd) {
                        this.mookReachedEnd(mook);
                    }
                }
                
                // Clean up inactive mooks
                this.mooks = this.mooks.filter(mook => mook.active || mook.reachedEnd);
            }
            
            updateTowers(time) {
                // Temporarily disable tower attacking here since we're handling it in the scene for visuals
                // This prevents double damage
                
                // We will re-enable this once we refactor to separate visual effects from game logic
                
                /*
                for (const tower of this.towers) {
                    // Try to attack a target
                    const attackResults = tower.attackTarget(time, this.mooks, 60); // 60 is cellSize
                    
                    // Process attack results
                    if (attackResults) {
                        for (const result of attackResults) {
                            if (result.isDead) {
                                this.mookKilled(result.mook);
                            }
                        }
                    }
                }
                */
            }
        }
    
        // Initialize the game after all scripts are loaded
        window.addEventListener('load', () => {
            // Wait 50ms to make sure all scripts are processed
            setTimeout(() => {
                // Initialize the game
                try {
                    const config = {
                        type: Phaser.AUTO,
                        width: window.innerWidth,
                        height: window.innerHeight,
                        parent: 'game-container',
                        backgroundColor: '#222222',
                        scene: [MapScene],  // Reference to external MapScene class
                        scale: {
                            mode: Phaser.Scale.RESIZE,
                            autoCenter: Phaser.Scale.CENTER_BOTH
                        }
                    };
                    
                    const game = new Phaser.Game(config);
                    
                    // Add game to window for debugging
                    window.game = game;
                    
                    console.log("Game created successfully");
                    
                    // Handle window resize events
                    window.addEventListener('resize', function() {
                        game.scale.resize(window.innerWidth, window.innerHeight);
                    });
                    
                } catch (error) {
                    console.error("Failed to create game:", error);
                    displayError("Game initialization failed: " + error.message);
                }
            }, 50);
        });
    </script>
</body>
</html>