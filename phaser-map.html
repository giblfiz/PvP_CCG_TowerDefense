<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Defense Map Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2d2d2d;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #info-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 100;
            font-size: 14px;
        }
        
        #help-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 100;
            font-size: 14px;
            text-align: right;
        }
        
        #hud-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            z-index: 100;
            font-size: 16px;
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        
        #tower-selection {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        .tower-button {
            width: 60px;
            height: 60px;
            background-color: #555;
            border: 2px solid #888;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 24px;
            transition: all 0.2s ease;
        }
        
        .tower-button:hover {
            border-color: #aaa;
            background-color: #666;
        }
        
        .tower-button.selected {
            border-color: #ffcc00;
            background-color: #775500;
        }
        
        .tower-cost {
            font-size: 12px;
            margin-top: 2px;
        }
        
        #error-display {
            position: fixed;
            bottom: 80px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
            display: none;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-weight: bold;
            min-width: 80px;
            text-align: right;
        }

        @media (max-width: 768px) {
            #info-panel, #help-panel {
                font-size: 12px;
                padding: 5px 8px;
            }
            
            .tower-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="info-panel">Tower Defense Map Demo</div>
    <div id="help-panel">
        üìå Drag to pan<br>
        üîç Pinch/scroll to zoom<br>
        üèóÔ∏è Click to place towers
    </div>
    <div id="game-container"></div>
    
    <div id="hud-panel">
        <div class="stat">
            <span class="stat-label">Gold:</span>
            <span class="stat-value" id="gold-value">600</span>
        </div>
        <div class="stat">
            <span class="stat-label">Lives:</span>
            <span class="stat-value" id="lives-value">20</span>
        </div>
        <div class="stat">
            <span class="stat-label">Wave:</span>
            <span class="stat-value" id="wave-value">0</span>
        </div>
        <div class="stat">
            <button id="wave-button" style="width: 100%; padding: 5px; margin-top: 5px; cursor: pointer;">Start Wave</button>
        </div>
    </div>
    
    <div id="tower-selection">
        <div class="tower-button" data-type="basic" data-cost="50">
            üóº
            <div class="tower-cost">50</div>
        </div>
        <div class="tower-button" data-type="sniper" data-cost="100">
            üèØ
            <div class="tower-cost">100</div>
        </div>
        <div class="tower-button" data-type="splash" data-cost="150">
            üè∞
            <div class="tower-cost">150</div>
        </div>
    </div>
    
    <div id="error-display"></div>

    <!-- Error handling script -->
    <script>
        // Custom error handler to display errors in the page
        const errorDisplay = document.getElementById('error-display');
        
        // Store original console methods
        const originalConsoleError = console.error;
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        
        // Override console.error
        console.error = function() {
            // Call original method
            originalConsoleError.apply(console, arguments);
            
            // Display in our error div
            const errorMessage = Array.from(arguments).join(' ');
            displayError('ERROR: ' + errorMessage);
        };
        
        // Override console.warn
        console.warn = function() {
            // Call original method
            originalConsoleWarn.apply(console, arguments);
            
            // Display in our error div
            const warnMessage = Array.from(arguments).join(' ');
            displayError('WARNING: ' + warnMessage);
        };
        
        // Handle window errors
        window.addEventListener('error', function(e) {
            displayError('EXCEPTION: ' + e.message + ' at ' + e.filename + ':' + e.lineno);
            return false;
        });
        
        // Handle promise rejections
        window.addEventListener('unhandledrejection', function(e) {
            displayError('UNHANDLED PROMISE REJECTION: ' + e.reason);
        });
        
        function displayError(message) {
            errorDisplay.style.display = 'block';
            const errorLine = document.createElement('div');
            errorLine.textContent = message;
            errorDisplay.appendChild(errorLine);
            
            // Scroll to bottom
            errorDisplay.scrollTop = errorDisplay.scrollHeight;
        }
    </script>

    <!-- Load Phaser library -->
    <script src="vendors/phaser/phaser.min.js" onerror="displayError('Failed to load Phaser library. Check if the file exists at vendors/phaser/phaser.min.js')"></script>
    
    <!-- Game code -->
    <script>
        // Check if Phaser exists before continuing
        if (typeof Phaser === 'undefined') {
            displayError('Phaser is not defined! The Phaser library failed to load correctly.');
        } else {
            console.log('Phaser loaded successfully:', Phaser.VERSION);
        }
    
        /**
         * Tower class definition
         */
        class Tower {
            static TOWER_BASIC = 'basic';
            static TOWER_SNIPER = 'sniper';
            static TOWER_SPLASH = 'splash';
            
            constructor(type, gridX, gridY) {
                this.type = type;
                this.gridX = gridX;
                this.gridY = gridY;
                this.level = 1;
                
                // Set stats based on tower type
                switch(type) {
                    case Tower.TOWER_BASIC:
                        this.damage = 20;
                        this.range = 3;
                        this.fireRate = 1;
                        this.cost = 50;
                        this.upgradeCost = 40;
                        this.emoji = 'üóº';
                        break;
                    case Tower.TOWER_SNIPER:
                        this.damage = 50;
                        this.range = 6;
                        this.fireRate = 0.5;
                        this.cost = 100;
                        this.upgradeCost = 80;
                        this.emoji = 'üèØ';
                        break;
                    case Tower.TOWER_SPLASH:
                        this.damage = 15;
                        this.range = 2;
                        this.fireRate = 0.8;
                        this.cost = 150;
                        this.upgradeCost = 120;
                        this.emoji = 'üè∞';
                        break;
                    default:
                        this.damage = 10;
                        this.range = 2;
                        this.fireRate = 1;
                        this.cost = 50;
                        this.upgradeCost = 40;
                        this.emoji = 'üóº';
                }
                
                this.lastFired = 0;
            }
            
            upgrade() {
                this.level++;
                this.damage *= 1.5;
                this.range += 0.5;
                this.fireRate *= 1.2;
                this.upgradeCost = Math.floor(this.upgradeCost * 1.5);
            }
            
            canFire(time) {
                return time - this.lastFired >= 1000 / this.fireRate;
            }
            
            fire(time) {
                this.lastFired = time;
                return this.damage;
            }
        }
    
        /**
         * Map definition
         */
        class TDMap {
            static CELL_EMPTY = 0;
            static CELL_PATH = 1;
            static CELL_SPAWN = 2;
            static CELL_EXIT = 3;
            static CELL_TOWER = 4;
            
            constructor(width = 20, height = 15) {
                this.width = width;
                this.height = height;
                
                // Initialize grid
                this.grid = [];
                for (let x = 0; x < this.width; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < this.height; y++) {
                        this.grid[x][y] = TDMap.CELL_EMPTY;
                    }
                }
                
                // Initialize paths, spawn points, and exit points
                this.paths = [];
                this.spawnPoints = [];
                this.exitPoints = [];
                
                // Generate a default map
                this.generateMap();
            }
            
            generateMap() {
                // Clear existing data
                this.paths = [];
                this.spawnPoints = [];
                this.exitPoints = [];
                
                // Reset grid to empty
                for (let x = 0; x < this.width; x++) {
                    for (let y = 0; y < this.height; y++) {
                        this.grid[x][y] = TDMap.CELL_EMPTY;
                    }
                }
                
                // Create a spawn point on the left edge
                const spawnY = Math.floor(Math.random() * this.height);
                const spawnPoint = { x: 0, y: spawnY };
                this.addSpawnPoint(spawnPoint.x, spawnPoint.y);
                
                // Create an exit point on the right edge
                const exitY = Math.floor(Math.random() * this.height);
                const exitPoint = { x: this.width - 1, y: exitY };
                this.addExitPoint(exitPoint.x, exitPoint.y);
                
                // Generate path from spawn to exit
                const path = this.findPath(spawnPoint, exitPoint);
                this.addPath(path);
            }
            
            findPath(start, end) {
                const path = [];
                let current = { ...start };
                path.push({ ...current });
                
                // Simple path algorithm - go horizontal first, then vertical
                while (current.x !== end.x || current.y !== end.y) {
                    // Move horizontally first
                    if (current.x < end.x) {
                        current.x += 1;
                    } else if (current.x > end.x) {
                        current.x -= 1;
                    }
                    // Then move vertically
                    else if (current.y < end.y) {
                        current.y += 1;
                    } else if (current.y > end.y) {
                        current.y -= 1;
                    }
                    
                    path.push({ ...current });
                }
                
                return path;
            }
            
            addSpawnPoint(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                this.spawnPoints.push({ x, y });
                this.grid[x][y] = TDMap.CELL_SPAWN;
                return true;
            }
            
            addExitPoint(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                this.exitPoints.push({ x, y });
                this.grid[x][y] = TDMap.CELL_EXIT;
                return true;
            }
            
            addPath(path) {
                // Verify path
                if (!Array.isArray(path) || path.length < 2) {
                    return false;
                }
                
                // Add path to map
                this.paths.push([...path]);
                
                // Mark all path cells in grid
                for (let i = 0; i < path.length; i++) {
                    const { x, y } = path[i];
                    if (this.isValidPosition(x, y)) {
                        // Skip overwriting spawn and exit points
                        if (this.grid[x][y] !== TDMap.CELL_SPAWN && this.grid[x][y] !== TDMap.CELL_EXIT) {
                            this.grid[x][y] = TDMap.CELL_PATH;
                        }
                    }
                }
                
                return true;
            }
            
            isValidPosition(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }
            
            getCellValue(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return -1;
                }
                
                return this.grid[x][y];
            }
            
            canPlaceTower(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                // Can only place towers on empty cells
                return this.grid[x][y] === TDMap.CELL_EMPTY;
            }
            
            placeTower(x, y) {
                if (!this.canPlaceTower(x, y)) {
                    return false;
                }
                
                this.grid[x][y] = TDMap.CELL_TOWER;
                return true;
            }
            
            removeTower(x, y) {
                if (!this.isValidPosition(x, y)) {
                    return false;
                }
                
                if (this.grid[x][y] === TDMap.CELL_TOWER) {
                    this.grid[x][y] = TDMap.CELL_EMPTY;
                    return true;
                }
                
                return false;
            }
        }
        
        /**
         * Game state
         */
        class GameState {
            constructor() {
                this.gold = 600;
                this.lives = 20;
                this.wave = 0;
                this.towers = [];
                this.waveActive = false;
                
                // Update UI
                this.updateUI();
            }
            
            addGold(amount) {
                this.gold += amount;
                this.updateUI();
            }
            
            spendGold(amount) {
                if (this.gold >= amount) {
                    this.gold -= amount;
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            reduceLives(amount) {
                this.lives -= amount;
                this.updateUI();
                
                if (this.lives <= 0) {
                    this.gameOver = true;
                }
            }
            
            startWave() {
                if (!this.waveActive) {
                    this.wave++;
                    this.waveActive = true;
                    this.updateUI();
                    
                    // Add bonus gold for starting a wave
                    this.addGold(25);
                    
                    return true;
                }
                return false;
            }
            
            endWave() {
                this.waveActive = false;
                
                // Add wave completion bonus
                this.addGold(50 + (this.wave * 10));
                
                this.updateUI();
                document.getElementById('wave-button').textContent = 'Start Wave';
            }
            
            updateUI() {
                document.getElementById('gold-value').textContent = this.gold;
                document.getElementById('lives-value').textContent = this.lives;
                document.getElementById('wave-value').textContent = this.wave;
                
                if (this.waveActive) {
                    document.getElementById('wave-button').textContent = 'Wave in Progress';
                    document.getElementById('wave-button').disabled = true;
                } else {
                    document.getElementById('wave-button').textContent = 'Start Wave';
                    document.getElementById('wave-button').disabled = false;
                }
            }
            
            addTower(tower) {
                this.towers.push(tower);
            }
            
            removeTower(gridX, gridY) {
                const index = this.towers.findIndex(t => t.gridX === gridX && t.gridY === gridY);
                if (index !== -1) {
                    const tower = this.towers[index];
                    this.towers.splice(index, 1);
                    
                    // Refund some of the cost
                    this.addGold(Math.floor(tower.cost * 0.7));
                    return true;
                }
                return false;
            }
            
            getTower(gridX, gridY) {
                return this.towers.find(t => t.gridX === gridX && t.gridY === gridY);
            }
        }
    
        class MapScene extends Phaser.Scene {
            constructor() {
                super('MapScene');
                
                // Camera and interaction state
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.pinchDistance = 0;
                this.currentZoom = 1;
                
                // Cell size in pixels
                this.cellSize = 60;
                
                // Tower placement
                this.selectedTowerType = null;
                this.placementPreview = null;
                
                // Game state
                this.gameState = new GameState();
            }
            
            preload() {
                // Create textures for map cells and towers
                this.createTextures();
            }
            
            createTextures() {
                // Create map cell textures
                this.createCellTextures();
                
                // Create tower textures
                this.createTowerTextures();
                
                // Create range indicator texture
                this.createRangeTexture();
            }
            
            createCellTextures() {
                // Empty cell texture
                this.createEmptyCellTexture('empty-cell');
                
                // Path cell texture
                this.createPathCellTexture('path-cell');
                
                // Spawn cell texture
                this.createSpawnCellTexture('spawn-cell');
                
                // Exit cell texture
                this.createExitCellTexture('exit-cell');
                
                // Tower cell texture (base)
                this.createTowerCellTexture('tower-cell');
            }
            
            createTowerTextures() {
                // Basic tower texture
                this.createBasicTowerTexture('basic-tower');
                
                // Sniper tower texture
                this.createSniperTowerTexture('sniper-tower');
                
                // Splash tower texture
                this.createSplashTowerTexture('splash-tower');
            }
            
            createEmptyCellTexture(key) {
                const graphics = this.make.graphics();
                graphics.fillStyle(0x333333);
                graphics.fillRect(0, 0, 100, 100);
                graphics.lineStyle(2, 0x555555);
                graphics.strokeRect(1, 1, 98, 98);
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createPathCellTexture(key) {
                const graphics = this.make.graphics();
                graphics.fillStyle(0x885500);
                graphics.fillRect(0, 0, 100, 100);
                graphics.lineStyle(2, 0xaa7722);
                graphics.strokeRect(1, 1, 98, 98);
                
                // Add path markings
                graphics.lineStyle(3, 0xffcc88);
                graphics.beginPath();
                graphics.moveTo(20, 50);
                graphics.lineTo(80, 50);
                graphics.strokePath();
                
                // Arrow
                graphics.lineTo(70, 40);
                graphics.moveTo(80, 50);
                graphics.lineTo(70, 60);
                graphics.strokePath();
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createSpawnCellTexture(key) {
                const graphics = this.make.graphics();
                graphics.fillStyle(0x00aa00);
                graphics.fillRect(0, 0, 100, 100);
                graphics.lineStyle(2, 0x00cc00);
                graphics.strokeRect(1, 1, 98, 98);
                
                // Add spawn symbol
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(50, 50, 30);
                graphics.fillStyle(0x00aa00);
                graphics.fillCircle(50, 50, 25);
                graphics.fillStyle(0xffffff);
                
                // Add arrow
                graphics.lineStyle(6, 0xffffff);
                graphics.beginPath();
                graphics.moveTo(35, 50);
                graphics.lineTo(75, 50);
                graphics.strokePath();
                graphics.beginPath();
                graphics.moveTo(65, 40);
                graphics.lineTo(75, 50);
                graphics.lineTo(65, 60);
                graphics.strokePath();
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createExitCellTexture(key) {
                const graphics = this.make.graphics();
                graphics.fillStyle(0xaa0000);
                graphics.fillRect(0, 0, 100, 100);
                graphics.lineStyle(2, 0xcc0000);
                graphics.strokeRect(1, 1, 98, 98);
                
                // Add exit symbol
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(50, 50, 30);
                graphics.fillStyle(0xaa0000);
                graphics.fillCircle(50, 50, 25);
                
                // Add X
                graphics.lineStyle(6, 0xffffff);
                graphics.beginPath();
                graphics.moveTo(35, 35);
                graphics.lineTo(65, 65);
                graphics.moveTo(65, 35);
                graphics.lineTo(35, 65);
                graphics.strokePath();
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createTowerCellTexture(key) {
                const graphics = this.make.graphics();
                graphics.fillStyle(0x555555);
                graphics.fillRect(0, 0, 100, 100);
                graphics.lineStyle(2, 0x777777);
                graphics.strokeRect(1, 1, 98, 98);
                
                // Add base platform
                graphics.fillStyle(0x666666);
                graphics.fillRect(10, 10, 80, 80);
                graphics.lineStyle(2, 0x888888);
                graphics.strokeRect(10, 10, 80, 80);
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createBasicTowerTexture(key) {
                const graphics = this.make.graphics();
                
                // Base
                graphics.fillStyle(0x666666);
                graphics.fillRect(0, 0, 100, 100);
                
                // Tower
                graphics.fillStyle(0x3399ff);
                graphics.fillRect(30, 20, 40, 60);
                
                // Top
                graphics.fillStyle(0x55aaff);
                graphics.fillRect(20, 10, 60, 20);
                
                // Border
                graphics.lineStyle(3, 0x333333);
                graphics.strokeRect(30, 20, 40, 60);
                graphics.strokeRect(20, 10, 60, 20);
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createSniperTowerTexture(key) {
                const graphics = this.make.graphics();
                
                // Base
                graphics.fillStyle(0x666666);
                graphics.fillRect(0, 0, 100, 100);
                
                // Tower
                graphics.fillStyle(0xff9900);
                graphics.fillRect(35, 15, 30, 70);
                
                // Top
                graphics.fillStyle(0xffaa00);
                graphics.fillRect(25, 5, 50, 20);
                
                // Border
                graphics.lineStyle(3, 0x333333);
                graphics.strokeRect(35, 15, 30, 70);
                graphics.strokeRect(25, 5, 50, 20);
                
                // Sniper scope
                graphics.fillStyle(0x333333);
                graphics.fillCircle(50, 35, 10);
                graphics.fillStyle(0xbbbbbb);
                graphics.fillCircle(50, 35, 6);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(50, 35, 3);
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createSplashTowerTexture(key) {
                const graphics = this.make.graphics();
                
                // Base
                graphics.fillStyle(0x666666);
                graphics.fillRect(0, 0, 100, 100);
                
                // Tower body
                graphics.fillStyle(0xff3366);
                graphics.fillRect(30, 30, 40, 40);
                
                // Tower sides
                graphics.fillStyle(0xcc3355);
                graphics.fillRect(20, 40, 10, 20);
                graphics.fillRect(70, 40, 10, 20);
                
                // Top
                graphics.fillStyle(0xff5577);
                graphics.fillRect(25, 20, 50, 20);
                
                // Border
                graphics.lineStyle(3, 0x333333);
                graphics.strokeRect(30, 30, 40, 40);
                graphics.strokeRect(20, 40, 10, 20);
                graphics.strokeRect(70, 40, 10, 20);
                graphics.strokeRect(25, 20, 50, 20);
                
                graphics.generateTexture(key, 100, 100);
                graphics.clear();
            }
            
            createRangeTexture() {
                const graphics = this.make.graphics();
                
                // Semi-transparent circle - make it centered properly
                graphics.fillStyle(0xffffff, 0.2);
                graphics.fillCircle(100, 100, 100);
                
                // Border
                graphics.lineStyle(2, 0xffffff, 0.5);
                graphics.strokeCircle(100, 100, 100);
                
                graphics.generateTexture('range-indicator', 200, 200);
                graphics.clear();
            }
            
            create() {
                try {
                    // Create the map
                    this.tdMap = new TDMap(20, 15);
                    
                    // Set up world boundaries
                    const worldWidth = this.tdMap.width * this.cellSize;
                    const worldHeight = this.tdMap.height * this.cellSize;
                    this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
                    
                    // Render the map
                    this.renderMap();
                    
                    // Set up camera controls
                    this.setupCameraControls();
                    
                    // Set up tower placement
                    this.setupTowerPlacement();
                    
                    // Set up wave controls
                    this.setupWaveControls();
                    
                    // Set up cell clicks for tower placement
                    this.setupCellClicks();
                    
                    // Add debug info
                    const infoPanel = document.getElementById('info-panel');
                    infoPanel.textContent = `Tower Defense Map - Gold: ${this.gameState.gold} - Zoom: ${this.currentZoom.toFixed(2)}x`;
                    
                } catch (error) {
                    console.error("Error in create method:", error);
                    displayError("Create method failed: " + error.message);
                }
            }
            
            renderMap() {
                // Container for all map cells
                this.mapContainer = this.add.container(0, 0);
                
                // Container for all towers
                this.towerContainer = this.add.container(0, 0);
                
                // Cells
                this.cellSprites = [];
                
                // Render grid
                for (let x = 0; x < this.tdMap.width; x++) {
                    this.cellSprites[x] = [];
                    for (let y = 0; y < this.tdMap.height; y++) {
                        const cellValue = this.tdMap.getCellValue(x, y);
                        let cellSprite;
                        
                        // Choose texture based on cell type
                        switch (cellValue) {
                            case TDMap.CELL_PATH:
                                cellSprite = this.add.image(x * this.cellSize + this.cellSize/2, y * this.cellSize + this.cellSize/2, 'path-cell');
                                break;
                            case TDMap.CELL_SPAWN:
                                cellSprite = this.add.image(x * this.cellSize + this.cellSize/2, y * this.cellSize + this.cellSize/2, 'spawn-cell');
                                break;
                            case TDMap.CELL_EXIT:
                                cellSprite = this.add.image(x * this.cellSize + this.cellSize/2, y * this.cellSize + this.cellSize/2, 'exit-cell');
                                break;
                            default:
                                cellSprite = this.add.image(x * this.cellSize + this.cellSize/2, y * this.cellSize + this.cellSize/2, 'empty-cell');
                        }
                        
                        cellSprite.setScale(this.cellSize/100); // Scale to cell size
                        cellSprite.setInteractive();
                        cellSprite.setData('gridX', x);
                        cellSprite.setData('gridY', y);
                        
                        this.cellSprites[x][y] = cellSprite;
                        this.mapContainer.add(cellSprite);
                        
                        // Add grid coordinates for reference (only on some cells to avoid clutter)
                        if (x % 5 === 0 && y % 5 === 0) {
                            const coordText = this.add.text(
                                x * this.cellSize + this.cellSize/2, 
                                y * this.cellSize + this.cellSize/2, 
                                `(${x},${y})`, 
                                {
                                    fontSize: '10px',
                                    color: '#ffffff',
                                    stroke: '#000000',
                                    strokeThickness: 2
                                }
                            );
                            coordText.setOrigin(0.5);
                            this.mapContainer.add(coordText);
                        }
                    }
                }
                
                // Render path(s) with arrows
                this.renderPaths();
                
                // Add placement preview
                this.placementPreview = this.add.container(0, 0);
                this.placementPreview.setVisible(false);
                
                // Preview range indicator
                this.rangeIndicator = this.add.image(0, 0, 'range-indicator');
                this.rangeIndicator.setOrigin(0.5, 0.5);
                this.rangeIndicator.setVisible(false);
                
                // Tower sprite for placement preview
                this.towerPreview = this.add.image(0, 0, 'basic-tower');
                this.towerPreview.setScale(this.cellSize/100 * 0.7);
                this.towerPreview.setVisible(false);
            }
            
            renderPaths() {
                // Draw path overlay with directional indicators
                if (this.tdMap.paths.length > 0) {
                    const path = this.tdMap.paths[0]; // Just render the first path for now
                    
                    // Create graphics for path overlay
                    const pathGraphics = this.add.graphics();
                    pathGraphics.lineStyle(3, 0xffff00, 0.5);
                    
                    // Draw path line
                    pathGraphics.beginPath();
                    pathGraphics.moveTo(
                        path[0].x * this.cellSize + this.cellSize/2,
                        path[0].y * this.cellSize + this.cellSize/2
                    );
                    
                    for (let i = 1; i < path.length; i++) {
                        pathGraphics.lineTo(
                            path[i].x * this.cellSize + this.cellSize/2,
                            path[i].y * this.cellSize + this.cellSize/2
                        );
                    }
                    
                    pathGraphics.strokePath();
                    
                    // Add directional arrows at intervals
                    for (let i = 1; i < path.length; i += 2) {
                        const prev = path[i-1];
                        const curr = path[i];
                        
                        // Calculate direction
                        const angle = Phaser.Math.Angle.Between(
                            prev.x * this.cellSize + this.cellSize/2,
                            prev.y * this.cellSize + this.cellSize/2,
                            curr.x * this.cellSize + this.cellSize/2,
                            curr.y * this.cellSize + this.cellSize/2
                        );
                        
                        // Create arrow sprite
                        const arrow = this.add.text(
                            curr.x * this.cellSize + this.cellSize/2,
                            curr.y * this.cellSize + this.cellSize/2,
                            '‚û°Ô∏è',
                            { fontSize: '20px' }
                        );
                        arrow.setOrigin(0.5);
                        arrow.setRotation(angle);
                        
                        this.mapContainer.add(arrow);
                    }
                }
            }
            
            setupTowerPlacement() {
                // Set up tower selection buttons
                const buttons = document.querySelectorAll('.tower-button');
                
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        const towerType = button.getAttribute('data-type');
                        const towerCost = parseInt(button.getAttribute('data-cost'));
                        
                        // Check if user has enough gold
                        if (this.gameState.gold < towerCost) {
                            displayError('Not enough gold to place this tower!');
                            return;
                        }
                        
                        // Select this tower type for placement
                        this.selectTowerType(towerType);
                        
                        // Update UI
                        buttons.forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                    });
                });
                
                // Listen for escape key to cancel placement
                this.input.keyboard.on('keydown-ESC', () => {
                    this.cancelTowerPlacement();
                    buttons.forEach(b => b.classList.remove('selected'));
                });
            }
            
            setupWaveControls() {
                // Set up wave button
                const waveButton = document.getElementById('wave-button');
                
                waveButton.addEventListener('click', () => {
                    if (!this.gameState.waveActive) {
                        this.gameState.startWave();
                        // In a full implementation, we would spawn enemies here
                        
                        // For this demo, automatically end wave after 5 seconds
                        this.time.delayedCall(5000, () => {
                            this.gameState.endWave();
                        });
                    }
                });
            }
            
            setupCellClicks() {
                // Add click handler for grid cells to place towers
                this.input.on('gameobjectdown', (pointer, gameObject) => {
                    // Only process if not dragging and we have a tower selected
                    if (!this.isDragging && this.selectedTowerType) {
                        const gridX = gameObject.getData('gridX');
                        const gridY = gameObject.getData('gridY');
                        
                        // Attempt to place a tower
                        this.placeTower(gridX, gridY);
                    }
                    // If right-click or holding shift, show tower info or remove
                    else if (!this.isDragging && (pointer.rightButtonDown() || this.input.keyboard.checkDown(this.input.keyboard.addKey('SHIFT')))) {
                        const gridX = gameObject.getData('gridX');
                        const gridY = gameObject.getData('gridY');
                        
                        // Check if there's a tower here
                        const tower = this.gameState.getTower(gridX, gridY);
                        if (tower) {
                            // If right-click, remove tower
                            if (pointer.rightButtonDown()) {
                                this.removeTower(gridX, gridY);
                            }
                            // Otherwise show tower info (not implemented yet)
                        }
                    }
                });
                
                // Add hover handler for placement preview
                this.input.on('gameobjectmove', (pointer, gameObject) => {
                    if (this.selectedTowerType) {
                        const gridX = gameObject.getData('gridX');
                        const gridY = gameObject.getData('gridY');
                        
                        // Show placement preview
                        this.showPlacementPreview(gridX, gridY);
                    }
                });
                
                // Add hover exit handler
                this.input.on('gameobjectout', (pointer, gameObject) => {
                    if (this.selectedTowerType) {
                        // Hide placement preview when not hovering over a cell
                        this.towerPreview.setVisible(false);
                        this.rangeIndicator.setVisible(false);
                    }
                });
            }
            
            selectTowerType(type) {
                this.selectedTowerType = type;
                
                // Update tower preview texture
                switch(type) {
                    case 'basic':
                        this.towerPreview.setTexture('basic-tower');
                        break;
                    case 'sniper':
                        this.towerPreview.setTexture('sniper-tower');
                        break;
                    case 'splash':
                        this.towerPreview.setTexture('splash-tower');
                        break;
                }
            }
            
            showPlacementPreview(gridX, gridY) {
                // Check if placement is valid
                const canPlace = this.tdMap.canPlaceTower(gridX, gridY);
                
                // Position the preview
                const worldX = gridX * this.cellSize + this.cellSize/2;
                const worldY = gridY * this.cellSize + this.cellSize/2;
                
                // Show tower preview
                this.towerPreview.setPosition(worldX, worldY);
                this.towerPreview.setVisible(true);
                
                // Set alpha based on placement validity
                this.towerPreview.setAlpha(canPlace ? 0.8 : 0.4);
                
                // Show range indicator
                this.rangeIndicator.setPosition(worldX, worldY);
                this.rangeIndicator.setVisible(true);
                
                // Set range scale based on tower type
                let range = 2;
                if (this.selectedTowerType === 'sniper') {
                    range = 6;
                } else if (this.selectedTowerType === 'splash') {
                    range = 2.5;
                }
                
                // Scale the range indicator
                const rangeScale = (range * this.cellSize) / 100;
                this.rangeIndicator.setScale(rangeScale);
                
                // Set range indicator alpha
                this.rangeIndicator.setAlpha(canPlace ? 0.5 : 0.2);
            }
            
            placeTower(gridX, gridY) {
                // Check if tower can be placed
                if (!this.tdMap.canPlaceTower(gridX, gridY)) {
                    displayError('Cannot place tower here!');
                    return false;
                }
                
                // Get tower cost based on type
                let cost = 50;
                if (this.selectedTowerType === 'sniper') {
                    cost = 100;
                } else if (this.selectedTowerType === 'splash') {
                    cost = 150;
                }
                
                // Check if player has enough gold
                if (this.gameState.gold < cost) {
                    displayError('Not enough gold to place this tower!');
                    return false;
                }
                
                // Create new tower
                const tower = new Tower(this.selectedTowerType, gridX, gridY);
                
                // Spend gold
                this.gameState.spendGold(tower.cost);
                
                // Update map
                this.tdMap.placeTower(gridX, gridY);
                
                // Add tower to game state
                this.gameState.addTower(tower);
                
                // Create tower sprite
                const worldX = gridX * this.cellSize + this.cellSize/2;
                const worldY = gridY * this.cellSize + this.cellSize/2;
                
                let towerSprite;
                switch(tower.type) {
                    case 'basic':
                        towerSprite = this.add.image(worldX, worldY, 'basic-tower');
                        break;
                    case 'sniper':
                        towerSprite = this.add.image(worldX, worldY, 'sniper-tower');
                        break;
                    case 'splash':
                        towerSprite = this.add.image(worldX, worldY, 'splash-tower');
                        break;
                    default:
                        towerSprite = this.add.image(worldX, worldY, 'basic-tower');
                }
                
                // Scale tower to fit cell
                towerSprite.setScale(this.cellSize/100 * 0.7);
                
                // Store reference to gridX and gridY for reference
                towerSprite.setData('gridX', gridX);
                towerSprite.setData('gridY', gridY);
                towerSprite.setData('tower', tower);
                
                // Add to container
                this.towerContainer.add(towerSprite);
                
                // Hide placement preview
                this.towerPreview.setVisible(false);
                this.rangeIndicator.setVisible(false);
                
                return true;
            }
            
            removeTower(gridX, gridY) {
                // Find tower at this grid position
                const tower = this.gameState.getTower(gridX, gridY);
                
                if (!tower) {
                    return false;
                }
                
                // Remove from game state
                if (this.gameState.removeTower(gridX, gridY)) {
                    // Update map
                    this.tdMap.removeTower(gridX, gridY);
                    
                    // Remove tower sprite
                    this.towerContainer.getAll().forEach(sprite => {
                        if (sprite.getData('gridX') === gridX && sprite.getData('gridY') === gridY) {
                            sprite.destroy();
                        }
                    });
                    
                    return true;
                }
                
                return false;
            }
            
            cancelTowerPlacement() {
                this.selectedTowerType = null;
                this.towerPreview.setVisible(false);
                this.rangeIndicator.setVisible(false);
            }
            
            setupCameraControls() {
                // Enable camera controls
                const cam = this.cameras.main;
                
                // Set initial position to center of the map
                const worldWidth = this.tdMap.width * this.cellSize;
                const worldHeight = this.tdMap.height * this.cellSize;
                cam.centerOn(worldWidth/2, worldHeight/2);
                
                // Drag to pan
                this.input.on('pointerdown', (pointer) => {
                    // If middle button or right button (or holding space), start panning
                    if (pointer.middleButtonDown() || 
                        (pointer.rightButtonDown() && !this.input.keyboard.checkDown(this.input.keyboard.addKey('SHIFT'))) || 
                        this.input.keyboard.checkDown(this.input.keyboard.addKey('SPACE'))) {
                        
                        this.isDragging = true;
                        this.dragStartX = pointer.x;
                        this.dragStartY = pointer.y;
                    }
                });
                
                this.input.on('pointermove', (pointer) => {
                    if (this.isDragging) {
                        const dx = (pointer.x - this.dragStartX) / cam.zoom;
                        const dy = (pointer.y - this.dragStartY) / cam.zoom;
                        
                        cam.scrollX -= dx;
                        cam.scrollY -= dy;
                        
                        this.dragStartX = pointer.x;
                        this.dragStartY = pointer.y;
                    }
                });
                
                this.input.on('pointerup', () => {
                    this.isDragging = false;
                });
                
                // Zoom with mouse wheel
                this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
                    const zoomFactor = 0.1;
                    const newZoom = deltaY > 0 ? 
                        Math.max(0.5, cam.zoom - zoomFactor) : 
                        Math.min(2, cam.zoom + zoomFactor);
                    
                    this.zoomCamera(newZoom, pointer.worldX, pointer.worldY);
                });
                
                // Touch controls for mobile
                this.input.addPointer(1); // Ensure we track 2 pointers for pinch
                
                this.input.on('pointermove', (pointer) => {
                    if (this.input.pointer1.isDown && this.input.pointer2.isDown) {
                        // This is a pinch
                        const currentDistance = Phaser.Math.Distance.Between(
                            this.input.pointer1.x, this.input.pointer1.y,
                            this.input.pointer2.x, this.input.pointer2.y
                        );
                        
                        if (this.pinchDistance > 0) {
                            const distanceDiff = currentDistance - this.pinchDistance;
                            const zoomFactor = 0.01;
                            
                            // Calculate center of pinch for zoom focus
                            const pinchCenterX = (this.input.pointer1.worldX + this.input.pointer2.worldX) / 2;
                            const pinchCenterY = (this.input.pointer1.worldY + this.input.pointer2.worldY) / 2;
                            
                            const newZoom = distanceDiff > 0 ? 
                                Math.min(2, cam.zoom + (zoomFactor * distanceDiff)) : 
                                Math.max(0.5, cam.zoom + (zoomFactor * distanceDiff));
                            
                            this.zoomCamera(newZoom, pinchCenterX, pinchCenterY);
                        }
                        
                        this.pinchDistance = currentDistance;
                        this.isDragging = false; // Disable drag during pinch
                    }
                });
                
                this.input.on('pointerup', () => {
                    if (!this.input.pointer1.isDown || !this.input.pointer2.isDown) {
                        this.pinchDistance = 0;
                    }
                });
                
                // Add key controls for zoom
                this.zoomInKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.PLUS);
                this.zoomOutKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.MINUS);
                
                // Add key controls for panning
                this.cursors = this.input.keyboard.createCursorKeys();
            }
            
            zoomCamera(newZoom, focusX, focusY) {
                // Store the pre-zoom camera position and focus point
                const cam = this.cameras.main;
                const oldZoom = cam.zoom;
                
                // Set the new zoom level
                cam.zoom = newZoom;
                this.currentZoom = newZoom;
                
                // Update camera position to maintain focus point
                if (focusX !== undefined && focusY !== undefined) {
                    const zoomFactor = newZoom / oldZoom;
                    
                    // Calculate how much the camera should move to maintain focus
                    const offsetX = (focusX - cam.worldView.centerX) * (1 - 1 / zoomFactor);
                    const offsetY = (focusY - cam.worldView.centerY) * (1 - 1 / zoomFactor);
                    
                    cam.scrollX += offsetX;
                    cam.scrollY += offsetY;
                }
                
                // Update text display to show current zoom level
                const infoPanel = document.getElementById('info-panel');
                infoPanel.textContent = `Tower Defense Map - Gold: ${this.gameState.gold} - Zoom: ${newZoom.toFixed(2)}x`;
            }
            
            update(time, delta) {
                // Keyboard controls for camera
                if (this.cursors) {
                    const speed = 10 / this.cameras.main.zoom;
                    
                    if (this.cursors.left.isDown) {
                        this.cameras.main.scrollX -= speed;
                    } else if (this.cursors.right.isDown) {
                        this.cameras.main.scrollX += speed;
                    }
                    
                    if (this.cursors.up.isDown) {
                        this.cameras.main.scrollY -= speed;
                    } else if (this.cursors.down.isDown) {
                        this.cameras.main.scrollY += speed;
                    }
                }
                
                // Keyboard zoom controls
                if (this.zoomInKey && this.zoomInKey.isDown) {
                    const newZoom = Math.min(2, this.cameras.main.zoom + 0.01);
                    this.zoomCamera(newZoom);
                } else if (this.zoomOutKey && this.zoomOutKey.isDown) {
                    const newZoom = Math.max(0.5, this.cameras.main.zoom - 0.01);
                    this.zoomCamera(newZoom);
                }
                
                // Update info panel with gold
                const infoPanel = document.getElementById('info-panel');
                infoPanel.textContent = `Tower Defense Map - Gold: ${this.gameState.gold} - Zoom: ${this.currentZoom.toFixed(2)}x`;
            }
        }
        
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game-container',
            backgroundColor: '#222222',
            scene: [MapScene],
            scale: {
                mode: Phaser.Scale.RESIZE,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };
        
        try {
            const game = new Phaser.Game(config);
            
            // Add game to window for debugging
            window.game = game;
            
            console.log("Game created successfully");
            
            // Handle window resize events
            window.addEventListener('resize', function() {
                game.scale.resize(window.innerWidth, window.innerHeight);
            });
            
        } catch (error) {
            console.error("Failed to create game:", error);
            displayError("Game initialization failed: " + error.message);
        }
    </script>
</body>
</html>